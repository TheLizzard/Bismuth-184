from __future__ import annotations
import re

try:
    from ..colourmanager import ColourManager as BaseColourManager
    from ..colourmanager import ColourConfig as BaseColourConfig
    from ..colourmanager import Regex, Parser as BaseParser
except:
    from colourmanager import ColourManager as BaseColourManager
    from colourmanager import ColourConfig as BaseColourConfig
    from colourmanager import Regex, Parser as BaseParser


# Use `compgen -k` to build this list
KEYWORDS:set[str] = {
    "break", "case", "continue", "coproc", "do", "done", "elif",
    "else", "esac", "fi", "for", "function", "if", "in", "select",
    "then", "time", "until", "while",
                     }

PROGRAMS:set[str] = {
    # Executables usually part of Linux
    "grep", "awk", "sed", "cat", "ls", "true", "false", "tee",
    "printf", "dd", "echo", "head", "tail", "cut", "sudo", "date",
    "swapon", "swapoff", "lsblk", "xargs", "chmod", "chown",
    "chgrp", "chroot", "mkswap", "mkdir", "mount", "tar", "rm",
    "rmdir", "cp", "mv", "realpath", "readlink", "dirname",
    "basename", "", "", "", "", "", "", "", "", "", "", "", "", ""
    # Signals (generated by ChatGPT)
    "SIGINT", "SIGILL", "SIGABRT", "SIGFPE", "SIGKILL", "SIGSEGV",
    "SIGPIPE", "SIGALRM", "SIGTERM", "SIGUSR1", "SIGUSR2", "SIGCHLD",
    "SIGCONT", "SIGSTOP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGBUS",
    "SIGPOLL", "SIGPROF", "SIGSYS", "SIGEMT", "SIGSTKFLT", "SIGCLD",
    "SIGWINCH", "SIGPWR",
    # Trap signals
    "ERR", "EXIT", "DEBUG", "RETURN",
    # Builtins (compgen -b)
    "alias", "bg", "bind", "builtin", "caller", "cd", "command",
    "compgen", "complete", "compopt", "declare", "dirs", "disown",
    "enable", "eval", "exec", "exit", "export", "fc", "fg",
    "getopts", "hash", "help", "history", "jobs", "let", "local",
    "logout", "mapfile", "popd", "pushd", "read", "readarray",
    "readonly", "return", "set", "shift", "shopt", "source",
    "suspend", "times", "trap", "type", "typeset", "ulimit",
    "umask", "unalias", "unset", "wait",
                    }
PROGRAMS.discard("")


class ColourConfig(BaseColourConfig):
    __slots__ = ()

    def __init__(self, kwargs:dict[str:dict[str:str]]={}) -> ColourConfig:
        super().__init__({
                           "comment":           dict(foreground="red"),
                           "keyword":           dict(foreground="orange"),
                           "string":            dict(foreground="lime"),
                           "program":           dict(foreground="#ff75ff"),
                           "variable":          dict(foreground="blue"),
                           "cmd-substitution":  dict(foreground="yellow"),
                           "here-doc":          dict(foreground="yellow"),
                           "flag":              dict(foreground="#999999"),
                           # "definition": dict(foreground="cyan"),
                           **kwargs
                        })

IDENTIFIER_REGEX:str = (
                         r"^" # Begining of the string
                         r"(?:" + # One of
                             "|".join((
                                         r"[^\W\d]", # Unicode letter/_
                                         r"\[",      # [
                                         r"\]",      # ]
                                     )) + r")"
                         r"[" # Followed by any number of
                             r"\w" # Unicode letter/digit/_
                             r"\[" # [
                             r"\]" # ]
                         r"]*"
                         r"$" # End of string
                       )
IDENTIFIER_REGEX:str = re.compile(IDENTIFIER_REGEX)

def isidentifier(text:str) -> bool:
    return bool(IDENTIFIER_REGEX.fullmatch(text))


class Parser(BaseParser):
    __slots__ = ()

    def __init__(self) -> Parser:
        super().__init__(isidentifier, negatives=False)

    def read(self) -> Iterable[TokenTypePair]:
        while True:
            token:Token = self.peek_token()
            # print("in:", (token,))
            if not token: break
            # Keywords
            if token in KEYWORDS:
                yield self.read_token(), "keyword"
            # Programs
            elif (self.seen_text[-1:] not in set(".'\"\\#")) and \
                                                           (token in PROGRAMS):
                yield self.read_token(), "program"
            # Comment
            elif token == "#":
                token:Token = self.read_token() # Read the "#"
                while True:
                    new_token:Token = self.read_token()
                    # Newline is not part of the comment
                    if new_token == "\n":
                        yield token, "comment"
                        yield "\n", "newline"
                        break
                    token += new_token
            # $
            elif token == "$":
                yield from self._read_after_dollar(self.read_token())
            # <<
            elif token == "<<":
                yield from self._read_here_doc()
            # Flags
            elif token == "-":
                if self.seen_text[-1:] in (" ", "\t", "-"):
                    yield self.read_flag(self.read_token()), "flag"
                else:
                    yield self.read_token(), ""
            # Strings without a prefix
            elif token in "'\"":
                yield from self.read_string()
            # [[/]]
            elif token in ("[","[["):
                close:str = "]" if token == "[" else "]]"
                yield self.read_token(), "program"
                for token, tokentype in self.read():
                    if (token == close) and (tokentype == "identifier"):
                        yield token, "program"
                        break
                    yield token, tokentype or "inside-test" # inside [ or [[
            # Identifiers
            elif self.isidentifier(token):
                yield self.read_token(), "identifier"
            # Default
            else:
                yield self.read_token(), ""

    def read_flag(self, dash_token:Token) -> Token:
        output:Token = dash_token
        while True:
            token:Token = self.peek_token()
            if not token: break
            if (token[0] != "-") and (not self.isidentifier("_"+token)):
                while token == "=":
                    output += self.read_token()
                    token:Token = self.peek_token()
                break
            output += self.read_token()
        return output

    def read_string(self) -> Iterable[TokenTypePair]:
        single:Token = self.read_token()
        output:Token = single
        # Actual string reading loop
        while True:
            token:Token = self.read_token()
            output += token
            # No data left => return
            if not token:
                yield output, "string"
                return
            # Newlines stop strings
            elif token == "\n":
                yield output, "string"
                return
            # Slash-Character (the character might be a newline)
            elif token == "\\":
                output += self.read_token() # Read the token after the \
            # On string-closing
            elif token == single:
                yield output, "string"
                return
            # F-string code
            elif token == "$":
                output:Token = output[:-1] # Remove dollar_token
                yield output, "string"
                begining_of_string:bool = output == single
                if begining_of_string:
                    location:Location = self.tell()
                    location -= 1 # The location before the dollar
                    location -= 1 # The location before the quote
                for token, tokentype in self._read_after_dollar(token):
                    yield token, tokentype
                if begining_of_string and (self.peek_token() == single):
                    if tokentype != "inside-here-doc":
                        self.override(location, 1, tokentype)
                        yield self.read_token(), tokentype
                        return
                output:Token = ""

    def _read_after_dollar(self, dollar_token:Token) -> Iterable[TokenTypePair]:
        """
        Reads:
            * (...)
            * variable
            * {variable}
        """
        # Check for bashslashes before dollar token
        text_before:str = self.seen_text[:-1]
        slashes:int = len(text_before) - len(text_before.rstrip("\\"))
        if slashes & 1:
            yield dollar_token, ""
            return

        token:Token = self.peek_token()
        # $variable
        if self.isidentifier(token):
            yield dollar_token + self.read_token(), "variable"
        # ${variable}
        elif token == "{":
            output:Token = dollar_token + self.read_token() # Read the "{"
            if self.isidentifier(self.peek_token()):
                output += self.read_token() # Read the variable
                if self.peek_token() == "}":
                    output += self.read_token() # Read the "}"
            yield output, "variable"
        # $0
        elif token[:1].isdigit():
            token:Token = self.read_token()
            number:str = ""
            while token and token[:1].isdigit():
                number, token = number+token[:1], token[1:]
            yield dollar_token+number, "variable"
            yield token, ""
        # Other special variables
        elif token in "#@*?$!-":
            yield dollar_token+self.read_token(), "variable"
        # $(···)
        elif token == "(":
            output:Token = dollar_token + self.read_token() # Read the "("
            yield output, "cmd-substitution"
            brackets:int = 1
            for token, tokentype in self.read():
                if tokentype == "inside-here-doc":
                    yield token, tokentype
                else:
                    if (token == "(") or (token == "$("):
                        brackets += 1
                    elif token == ")":
                        brackets -= 1
                        if brackets == 0:
                            yield token, "cmd-substitution"
                            break
                    yield token, tokentype or "no-sync"
        # Incomplete variable
        else:
            # I would yield tokentype="variable" but "$" can appear in regexes
            #   if [[ ... =~ ^xxx$ ]]
            yield dollar_token, ""

    def _read_here_doc(self) -> Iterable[TokenTypePair]:
        token:Token = self.read_token()
        assert token == "<<", "This should only be called if next_token == <<"
        yield token, "here-doc"
        yield self.read_join_spaces(" \t"), "" # Eat spaces
        # Get the next token
        for delim, delimtype in self.read():
            break
        else:
            return
        # << EOL
        if delimtype == "identifier":
            yield delim, "here-doc"
            subs:int = 0
            for token, tokentype in self.read():
                if tokentype == "cmd-substitution":
                    subs += token.endswith("(") - (token == ")")
                elif tokentype != "variable":
                    if not subs:
                        tokentype:str = ""
                # else:
                #     tokentype:str = "inside-here-doc"
                yield token, tokentype or "inside-here-doc" # Disable sync
                if (token == "\n") and (self.peek_token() == delim):
                    yield self.read_token(), "here-doc"
                    break
                if token == "\\": # Skip the token after \
                    for token, tokentype in self.read():
                        yield token, tokentype or "no-sync"
                        break
        # <<'EOL'/<<"EOL"
        elif delimtype == "string":
            yield delim, "here-doc"
            # Remove the quotation marks around the delimiter
            delim:str = delim.removeprefix(delim[-1]).removesuffix(delim[-1])
            # Read until the end of the line after the here-doc delimiter
            while True:
                token:Token = self.read_token()
                if token == "\n":
                    yield token, "inside-here-doc"
                    break
            # Read lines until delimiter
            while True:
                line:Token = ""
                while True:
                    token:Token = self.read_token()
                    if not token: break
                    line += token
                    if (token == "\n") or (line == delim):
                        break
                if line == delim:
                    yield line, "here-doc"
                    break
                yield line, "inside-here-doc"
                if not token: break
        else:
            yield delim, "here-doc"


class ColourManager(BaseColourManager):
    __slots__ = ()

    def init(self) -> None:
        self.tagdefs:dict[str,str] = ColourConfig()
        self.prog = Regex(Parser())