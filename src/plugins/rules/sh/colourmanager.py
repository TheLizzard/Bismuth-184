from __future__ import annotations
import re

try:
    from ..colourmanager import ColourManager as BaseColourManager
    from ..colourmanager import ColourConfig as BaseColourConfig
    from ..colourmanager import Regex, Parser as BaseParser
except:
    from colourmanager import ColourManager as BaseColourManager
    from colourmanager import ColourConfig as BaseColourConfig
    from colourmanager import Regex, Parser as BaseParser


# Use `compgen -k` to build this list
KEYWORDS:set[str] = {
    "break", "case", "continue", "coproc", "do", "done", "elif",
    "else", "esac", "fi", "for", "function", "if", "select",
    "then", "time", "until", "while", "return",
    # "in" is special
}

SIGNALS_TRAPS:set[str] = {
    # Signals (generated by ChatGPT)
    "SIGINT", "SIGILL", "SIGABRT", "SIGFPE", "SIGKILL", "SIGSEGV",
    "SIGPIPE", "SIGALRM", "SIGTERM", "SIGUSR1", "SIGUSR2", "SIGCHLD",
    "SIGCONT", "SIGSTOP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGBUS",
    "SIGPOLL", "SIGPROF", "SIGSYS", "SIGEMT", "SIGSTKFLT", "SIGCLD",
    "SIGWINCH", "SIGPWR",
    # Trap signals
    "ERR", "EXIT", "DEBUG", "RETURN", "HUP", "INT", "QUIT", "TSTP",
}

PROGRAMS:set[str] = {
    # Common Linux utils
    "adduser", "ar", "ash", "awk", "basename", "beep", "blkid", "cal",
    "cat", "chgrp", "chmod", "chown", "chpasswd", "chroot", "chrt",
    "chvt", "cksum", "clear", "cmp", "cp", "cpio", "cut", "date", "dd",
    "deallocvt", "delgroup", "deluser", "depmod", "df", "diff",
    "dirname", "dos2unix", "dpkg", "du", "echo", "eject", "env",
    "expand", "expr", "false", "fdflush", "fdisk", "find", "findfs",
    "fold", "free", "fsck", "fsync", "fuser", "getopt", "getty", "git",
    "grep", "gzip", "head", "hexdump", "hostid", "hostname", "hwclock",
    "id", "ifconfig", "ifdown", "ifup", "insmod", "ionice", "ip",
    "ipaddr", "iplink", "iproute", "iptunnel", "kill", "killall", "last",
    "length", "less", "ln", "loadfont", "loadkmap", "login", "logname",
    "ls", "lsattr", "lsblk", "lsmod", "man", "md5sum", "mesg", "mkdir",
    "mkdosfs", "mkfifo", "mkpasswd", "mkswap", "mktemp", "modprobe",
    "more", "mount", "mountpoint", "mv", "nc", "netstat", "nice", "nohup",
    "openvt", "passwd", "patch", "pidof", "ping", "ping6", "pivot_root",
    "pkill", "printenv", "printf", "ps", "pwd", "read", "readlink",
    "realpath", "renice", "reset", "resize", "rm", "rmdir", "rmmod",
    "script", "sed", "seq", "setconsole", "setfont", "sh", "sha1sum",
    "sha256sum", "sha512sum", "showkey", "sleep", "softlimit", "sort",
    "split", "stat", "strings", "stty", "su", "sudo", "sum", "swapoff",
    "swapon", "switch_root", "sync", "tail", "tar", "tee", "test", "time",
    "top", "touch", "tr", "true", "truncate", "tsort", "tty", "umount",
    "uname", "uniq", "uptime", "usleep", "uuencode", "vlock", "watch",
    "watchdog", "wc", "which", "who", "whoami", "xargs", "yes",
    "", "", "",
    # Signals and traps
    *SIGNALS_TRAPS,
    # Builtins (compgen -b)
    "alias", "bg", "bind", "builtin", "caller", "cd", "command",
    "compgen", "complete", "compopt", "declare", "dirs", "disown",
    "enable", "eval", "exec", "exit", "export", "fc", "fg",
    "getopts", "hash", "help", "history", "jobs", "let", "local",
    "logout", "mapfile", "popd", "pushd", "read", "readarray",
    "readonly", "set", "shift", "shopt", "source", "suspend",
    "times", "trap", "type", "typeset", "ulimit", "umask", "unalias",
    "unset", "wait",
}
PROGRAMS.discard("")

SPECIAL_VARS:set[str] = set("#@*?$!-")
NEW_STATEMENT_BEFORE:set[str] = {";", "\n", "(", "{", "|", "&", "", "!"}
PROGRAM_PROGRAMS:set[str] = {"sudo", "which", "exec"}


class ColourConfig(BaseColourConfig):
    __slots__ = ()

    def __init__(self, kwargs:dict[str:dict[str:str]]={}) -> ColourConfig:
        super().__init__({
                           "comment":           dict(foreground="red"),
                           "keyword":           dict(foreground="orange"),
                           "string":            dict(foreground="lime"),
                           "program":           dict(foreground="#ff75ff"),
                           "variable":          dict(foreground="cyan"),
                           "cmd-substitution":  dict(foreground="yellow"),
                           "here-doc":          dict(foreground="yellow"),
                           "flag":              dict(foreground="#c0c0c0"),
                           **kwargs
                        })

VARIABLE_IGNORE_TYPES:set[str] = {"cmd-substitution"}

IDENTIFIER_REGEX:str = (
    r"^" + # Begining of the string
    r"(?:" + # One of
        "|".join([
            r"[^\W\d]",            # Unicode letter/"_"
        ]) + r")" +
    r"[" + # Followed by any number of
        r"\w" +            # Unicode letter/digit/"_"
    r"]*" +
    r"$" # End of string
)
IDENTIFIER_REGEX:str = re.compile(IDENTIFIER_REGEX)

def isidentifier(text:str) -> bool:
    return bool(IDENTIFIER_REGEX.fullmatch(text))


class Parser(BaseParser):
    __slots__ = ()

    def __init__(self) -> Parser:
        super().__init__(isidentifier=isidentifier, isnumber=str.isdigit)

    def prev_token_line(self) -> tuple[Token,TokenType]:
        prev:Location = self.tell()
        while prev:
            prev:Location = self.prev_start(prev)
            if prev is None: break
            prev_token:Token = self.token_at(prev)
            if prev_token == "\n":
                prev:Location = self.prev_start(prev)
                if prev is None: break
                prev_token:Token = self.token_at(prev)
                if prev_token == "\\": continue
                return "\n", self.tokentype_at(prev)
            elif not prev_token.strip(" \t"):
                continue
            return prev_token, self.tokentype_at(prev)
        return "", ""

    def read(self) -> None:
        token:Token = self.peek_token()
        # print("in:", (token,))
        if not token: return None
        if token in KEYWORDS: # Keywords
            tokentype:TokenType = "identifier"
            prev_token, prev_type = self.prev_token_line()
            if prev_token in NEW_STATEMENT_BEFORE:
                tokentype:TokenType = "keyword"
            elif prev_type == "keyword":
                if prev_token in {"then", "do"}:
                    tokentype:TokenType = "keyword"
            self.set(tokentype)
            if (tokentype == "keyword") and (token in ("for", "case")):
                self.skip_whitespaces(" \t") # Eat spaces
                self.read()
                self.skip_whitespaces(" \t") # Eat spaces
                if self.peek_token() == "in":
                    self.set("keyword")
        elif token in PROGRAMS: # Programs
            isprogram:bool = False
            prev_token, prev_type = self.prev_token_line()
            if prev_token in NEW_STATEMENT_BEFORE:
                isprogram:bool = True
            if (prev_type == "keyword") and (prev_token not in ("for","in")):
                isprogram:bool = True
            if token in SIGNALS_TRAPS:
                isprogram:bool = True
            if (prev_type == "program") and (prev_token in PROGRAM_PROGRAMS):
                isprogram:bool = True
            start:Location = self.tell()
            self.set("identifier")
            if isprogram and (self.peek_token() != "="):
                self.set("program", start)
                # Programs are allowed to have "-" in their names
                while True:
                    token:Token = self.peek_token()
                    if not (isidentifier(token) or (token == "-")): break
                    if token == "=": break
                    if not token: break
                    self.set("program")
        elif token == "#": # Comment
            self.set("comment") # Read the "#"
            while self.peek_token() != "\n": # Newline not in comment
                self.set("comment")
        elif token == "$": # $
            # Check for bashslashes before dollar
            curr_line:str = self.curr_line_seen()
            slashes:int = len(curr_line) - len(curr_line.rstrip("\\"))
            if slashes & 1:
                self.skip()
            else:
                self._read_dollar()
        elif token == "<": # here-doc
            start:Location = self.tell()
            self.skip()
            if self.peek_token() == "<":
                self.skip()
                self._read_here_doc(start)
        elif token == "-": # Flag
            if self.curr_line_seen()[-1:] in " \t-":
                self.read_flag()
            else:
                self.skip()
        elif token in "'\"": # String
            self.read_string()
        elif token == "[":
            prev_token:Token = self.prev_token().strip(" \t")
            if prev_token not in NEW_STATEMENT_BEFORE:
                self.skip()
            else:
                self.set("program") # Read the first "["
                double:bool = self.peek_token() == "["
                if double:
                    self.set("program") # Read the second "["
                while True:
                    token:Token = self.read_wait_for({"[","]",";"})
                    if token in ";": break
                    if (token == "[") or self.prev_token().strip(" \t"):
                        self.skip()
                        continue
                    start:Location = self.tell()
                    self.skip()
                    if double:
                        if self.peek_token() != "]": continue
                        self.set("program")
                    self.set("program", start)
                    break
        elif token == "\\":
            self.skip()
            if self.peek_token() == "\n":
                self.set("no-sync-backslash")
            else:
                self.skip()
        else: # Default
            self.skip()

    def dollar_only_read(self) -> None:
        token:Token = self.peek_token()
        # print("in:", (token,))
        if not token: return None
        if token == "$":
            # Check for bashslashes before dollar
            curr_line:str = self.curr_line_seen()
            slashes:int = len(curr_line) - len(curr_line.rstrip("\\"))
            if slashes & 1:
                self.skip()
            else:
                self._read_dollar()
        else: # Default
            self.skip()

    def read_flag(self) -> None:
        self.set("flag") # Read the dash
        while True:
            token:Token = self.peek_token()
            if not token:
                break
            elif token == "-": # "--flag-with-dash"
                self.set("flag")
            elif self.isidentifier("_" + token): # "-flag"
                self.set("flag")
            elif token == "=": # "--flag=value"
                self.set("flag") # Should this be coloured?
                break
            else:
                break

    def read_string(self) -> None:
        single:Token = self.peek_token()
        assert single in ("'",'"'), "InternalError"
        self.set("string") # Read the starting quote
        string_start:Location = self.tell() # Right after `single`
        # Actual string reading loop
        while True:
            token:Token = self.peek_token()
            if not token: # End of file
                break
            elif token == "\n":
                self.set("string")
            elif token == "\\":  # Slash+Character
                self.set("string") # Read the slash
                if single != "'":
                    # In bash, you can't escape single quotes in single
                    #   quote strings
                    self.set("string") # Read the token after the \ (can be \n)
            elif token == single: # On string-closing
                self.set("string")
                break
            elif (token == "$") and (single == '"'):
                curr:Location = self.tell()
                begining_of_string:bool = curr == string_start
                tokentype:str = self._read_dollar()
                if not tokentype:
                    self.set("string", curr)
                elif begining_of_string and (self.peek_token() == single):
                    self.set(tokentype, string_start-len(single)) # Quote
                    self.set(tokentype) # End quote
                    break
            else: # Default
                self.set("string")

    def _read_dollar(self) -> str:
        """
        Reads:
            * $(...)
            * $variable
            * ${variable}
        """
        dollar_start:Location = self.tell()
        assert self.peek_token() == "$", "InternalError"
        self.skip() # Read the dollar sign
        token:Token = self.peek_token()
        # $variable
        if self.isidentifier(token):
            self.set("variable", dollar_start)
            self.set("variable") # Read the variable
            return "variable"
        # ${variable}
        elif token == "{":
            # I am not even sure what I did here but it seems to work for
            #   now. From just this section, I started to hate bash's syntax
            # https://chatgpt.com/share/68f29e72-e504-8005-9e5f-995bf6e5de27
            self.set("variable", dollar_start)
            self.set("variable") # Read the "{"
            token:Token = self.peek_token()
            if token == "}":
                self.set("variable") # Read the "}"
                return "variable"
            token_is_var:bool = self.isidentifier(token) or \
                                token.isdigit() or \
                                (token in SPECIAL_VARS)
            if token_is_var:
                self.set("variable")
                start:Location = self.tell()
                while True:
                    token:Token = self.read_wait_for({"}","\n","#","$","\\"},
                                                     settype="string",
                                             ignoretypes=VARIABLE_IGNORE_TYPES)
                    if token == "#":
                        self.set("string")
                    elif token == "$":
                        self.read()
                    elif token == "\\":
                        self.set("string") # "\"
                        self.set("string") # Token after "\"
                    elif token == "}":
                        self.set("variable") # Read the "}"
                        break
                    else:
                        break
            return "variable"
        # $0/$@/$#/···
        elif token.isdigit() or (token in SPECIAL_VARS):
            self.set("variable", dollar_start)
            self.set("variable") # Read the token
            return "variable"
        # $(···)
        elif token == "(":
            self.set("cmd-substitution", dollar_start)
            self.set("cmd-substitution") # Read the "("
            double:bool = self.peek_token() == "(" # $((...))
            if double:
                self.set("cmd-substitution")
            while True:
                token:Token = self.read_wait_for({")","\\"})
                if not token: break
                if token == "\\":
                    # On "\\"
                    self.read() # Read the "\\"
                    self.read() # Read the token after the "\\"
                else:
                    # On ")"
                    if double:
                        start:Location = self.tell()
                        self.skip()
                        if self.peek_token() == ")":
                            self.set("cmd-substitution", start) # Read the ")"
                            self.set("cmd-substitution") # Read the second ")"
                            break
                    else:
                        self.set("cmd-substitution") # Read the ")"
                        break
            return "cmd-substitution"
        # Incomplete variable
        else:
            # I would yield tokentype="variable" but "$" can appear in regexes
            #   if [[ ... =~ ^xxx$ ]]
            return ""
        raise NotImplementedError("Unreachable")

    def _read_here_doc(self, start:Location) -> None:
        assert self.text_between(start, self.tell()) == "<<", "InternalError"
        self.set("here-doc", start) # Read the first "<"
        self.set("here-doc", start+1) # Read the second "<"
        token:Token = self.peek_token()
        if token == "<": # Here-strings
            self.set("here-doc") # Read the third "<"
            return None
        if ignore_tabs := (token == "-"):
            self.set("here-doc") # Read the dash in "<<-"
        self.skip_whitespaces(" \t") # Eat spaces
        start:Location = self.tell()
         # Read a token for the delimiter
        if self.peek_token() in ("'", '"'):
            self.read_string()
        else:
            self.skip()
        delimiter:Token = self.text_between(start, self.tell())
        if not delimiter: return None
        self.set_from("here-doc", start)
        # Check if 'EOL' or "EOL"
        ignore_tokentype:bool = delimiter[:1] in ("'", '"')
        if ignore_tokentype:
            # Remove quotes from delimiter
            delimiter:Token = delimiter[1:].removesuffix(delimiter[:1])
            read_func:Callable[None] = self.skip
        else:
            read_func:Callable[None] = self.dollar_only_read
        # Read the here-doc
        start:Location = self.tell()
        while True:
            token:Token = self.read_wait_for({"\n"}, read_func=read_func)
            if not token: break
            self.set("no-sync-here-doc") # Read the "\n"
            # Check for delimiter
            line:str = self.line_around(self.tell())
            if ignore_tabs:
                line:str = line.lstrip("\t")
            if line == delimiter:
                while self.peek_token() != "\n":
                    self.set("here-doc")
                break


class ColourManager(BaseColourManager):
    __slots__ = ()

    def init(self) -> None:
        self.tagdefs:dict[str,str] = ColourConfig()
        self.prog = Regex(Parser())
