from __future__ import annotations
import re

try:
    from ..colourmanager import ColourManager as BaseColourManager
    from ..colourmanager import ColourConfig as BaseColourConfig
    from ..colourmanager import Regex, Parser as BaseParser
except:
    from colourmanager import ColourManager as BaseColourManager
    from colourmanager import ColourConfig as BaseColourConfig
    from colourmanager import Regex, Parser as BaseParser


# Use `compgen -k` to build this list
KEYWORDS:set[str] = {
    "break", "case", "continue", "coproc", "do", "done", "elif",
    "else", "esac", "fi", "for", "function", "if", "in", "select",
    "then", "time", "until", "while",
                     }

PROGRAMS:set[str] = {
    # Common Linux utils
    "grep", "awk", "sed", "cat", "ls", "true", "false", "tee",
    "printf", "dd", "echo", "head", "tail", "cut", "sudo", "date",
    "swapon", "swapoff", "lsblk", "xargs", "chmod", "chown",
    "chgrp", "chroot", "mkswap", "mkdir", "mount", "tar", "rm",
    "rmdir", "cp", "mv", "realpath", "readlink", "dirname", "ln",
    "basename", "git", "ls", "find", "", "", "", "", "", "", "",
    "", "", ""
    # Signals (generated by ChatGPT)
    "SIGINT", "SIGILL", "SIGABRT", "SIGFPE", "SIGKILL", "SIGSEGV",
    "SIGPIPE", "SIGALRM", "SIGTERM", "SIGUSR1", "SIGUSR2", "SIGCHLD",
    "SIGCONT", "SIGSTOP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGBUS",
    "SIGPOLL", "SIGPROF", "SIGSYS", "SIGEMT", "SIGSTKFLT", "SIGCLD",
    "SIGWINCH", "SIGPWR",
    # Trap signals
    "ERR", "EXIT", "DEBUG", "RETURN",
    # Builtins (compgen -b)
    "alias", "bg", "bind", "builtin", "caller", "cd", "command",
    "compgen", "complete", "compopt", "declare", "dirs", "disown",
    "enable", "eval", "exec", "exit", "export", "fc", "fg",
    "getopts", "hash", "help", "history", "jobs", "let", "local",
    "logout", "mapfile", "popd", "pushd", "read", "readarray",
    "readonly", "return", "set", "shift", "shopt", "source",
    "suspend", "times", "trap", "type", "typeset", "ulimit",
    "umask", "unalias", "unset", "wait",
                    }
PROGRAMS.discard("")

SPECIAL_VARIABLES:set[str] = set("#@*?$!-")


class ColourConfig(BaseColourConfig):
    __slots__ = ()

    def __init__(self, kwargs:dict[str:dict[str:str]]={}) -> ColourConfig:
        super().__init__({
                           "comment":           dict(foreground="red"),
                           "keyword":           dict(foreground="orange"),
                           "string":            dict(foreground="lime"),
                           "program":           dict(foreground="#ff75ff"),
                           "variable":          dict(foreground="cyan"),
                           "cmd-substitution":  dict(foreground="yellow"),
                           "here-doc":          dict(foreground="yellow"),
                           "flag":              dict(foreground="#c0c0c0"),
                           # "definition": dict(foreground="cyan"),
                           **kwargs
                        })

IDENTIFIER_REGEX:str = (
                         r"^" # Begining of the string
                         r"(?:" + # One of
                             "|".join((
                                         r"[^\W\d]", # Unicode letter/_
                                         r"\[",      # [
                                         r"\]",      # ]
                                     )) + r")"
                         r"[" # Followed by any number of
                             r"\w" # Unicode letter/digit/_
                             r"\[" # [
                             r"\]" # ]
                         r"]*"
                         r"$" # End of string
                       )
IDENTIFIER_REGEX:str = re.compile(IDENTIFIER_REGEX)

def isidentifier(text:str) -> bool:
    return bool(IDENTIFIER_REGEX.fullmatch(text))


class Parser(BaseParser):
    __slots__ = ()

    def __init__(self) -> Parser:
        super().__init__(isidentifier=isidentifier, isnumber=str.isdigit)

    def read(self) -> None:
        token:Token = self.peek_token()
        # print("in:", (token,))
        if not token: return None
        if token in KEYWORDS: # Keywords
            self.set("keyword")
        elif token in PROGRAMS: # Programs
            line:str = self.curr_line_seen(respect_slashes=True).rstrip(" \t")
            if (line[-1:] in ";\n(") or (line[-2:] in ("&&", "||")):
                self.set("program")
            else:
                self.set("identifier")
        elif token == "#": # Comment
            self.set("comment") # Read the "#"
            while self.peek_token() != "\n": # Newline not in comment
                self.set("comment")
        elif token == "$": # $
            # Check for bashslashes before dollar
            curr_line:str = self.curr_line_seen()
            slashes:int = len(curr_line) - len(curr_line.rstrip("\\"))
            if slashes & 1:
                self.skip()
            else:
                self._read_dollar()
        elif token == "<": # here-doc
            start:Location = self.tell()
            self.skip()
            if self.peek_token() == "<":
                self.skip()
                self._read_here_doc(start)
        elif token == "-": # Flag
            if self.curr_line_seen()[-1:] in (" ", "\t", "-"):
                self.read_flag()
            else:
                self.skip()
        elif token in "'\"": # String
            self.read_string()
        elif token in ("[","[["): # test command
            close:str = "]" * len(token)
            self.set("program")
            for start, token, tokentype in self.read_tokens():
                if (token == close) and (tokentype == "identifier"):
                    self.set("program", start)
                    break
                elif token == "\n":
                    self.set("inside-program", start)
        elif self.isidentifier(token): # Identifiers
            self.set("identifier")
        else: # Default
            self.skip()

    def read_flag(self) -> None:
        self.set("flag") # Read the dash
        while True:
            token:Token = self.peek_token()
            if not token:
                break
            elif token == "-": # "--flag-with-dash"
                self.set("flag")
            elif self.isidentifier("_" + token): # "-flag"
                self.set("flag")
            elif token == "=": # "--flag=value"
                self.set("flag")
                break
            else:
                break

    def read_string(self) -> None:
        single:Token = self.peek_token()
        assert single in ("'",'"'), "InternalError"
        self.set("string") # Read the starting quote
        string_start:Location = self.tell() # Right after `single`
        # Actual string reading loop
        while True:
            token:Token = self.peek_token()
            if not token: # End of file
                break
            elif token == "\n":
                self.set("string")
                if single != "'": # Newlines only stop double quote strings
                    break
            elif token == "\\":  # Slash+Character
                self.set("string") # Read the slash
                self.set("string") # Read the token after the \ (might be \n)
            elif token == single: # On string-closing
                self.set("string")
                break
            elif token == "$":
                curr:Location = self.tell()
                begining_of_string:bool = curr == string_start
                tokentype:str = self._read_dollar()
                if not tokentype:
                    self.set("string", curr)
                elif begining_of_string and (self.peek_token() == single):
                    self.set(tokentype, string_start-len(single)) # Quote
                    self.set(tokentype) # End quote
                    break
            else: # Default
                self.set("string")

    def _read_dollar(self) -> str:
        """
        Reads:
            * $(...)
            * $variable
            * ${variable}
        """
        dollar_start:Location = self.tell()
        assert self.peek_token() == "$", "InternalError"
        self.skip() # Read the dollar sign
        token:Token = self.peek_token()
        # $variable
        if self.isidentifier(token):
            self.set("variable", dollar_start)
            self.set("variable") # Read the variable
            return "variable"
        # ${variable}
        elif token == "{":
            # I am not even sure what I did here but it seems to work for
            #   now. From just this section, I started to hate bash's syntax
            # https://chatgpt.com/share/68f29e72-e504-8005-9e5f-995bf6e5de27
            self.set("variable", dollar_start)
            self.set("variable") # Read the "{"
            if self.isidentifier(self.peek_token()):
                self.set("variable") # Read the variable
                token:Token = self.peek_token()
                if token in ":-=+#":
                    # :- := :+ :?
                    if token == ":":
                        self.set("variable") # The colon
                        if (self.peek_token() or "n") in "-=+?":
                            self.set("variable")
                    # - = +
                    elif token in "-=+":
                        self.set("variable")
                    # % # %% ##
                    elif token in "%#":
                        self.set("variable")
                        if self.peek_token() == token:
                            self.set("variable")
                    # Read
                    subs:int = 0
                    for start, token, tokentype in self.read_tokens():
                        if tokentype == "cmd-substitution":
                            subs += token.endswith("(") - (token == ")")
                        elif token == "\n": break
                        elif (token == "}") and (not tokentype):
                            self.set("variable", start)
                            return "variable"
                        elif tokentype in ("program", "identifier"):
                            if not subs:
                                self.set("string", start)
                        else:
                            self.set(tokentype or "string", start)
            if self.peek_token() == "}":
                self.set("variable") # Read the "}"
            return "variable"
        # $0/$@/$#/···
        elif token.isdigit() or (token in SPECIAL_VARIABLES):
            self.set("variable", dollar_start)
            self.set("variable") # Read the token
            return "variable"
        # $(···)
        elif token == "(":
            self.set("cmd-substitution", dollar_start)
            self.set("cmd-substitution") # Read the "("
            brackets:int = 1
            for start, token, tokentype in self.read_tokens():
                if tokentype != "inside-here-doc":
                    brackets += (token == "(") - (token == ")")
                    if brackets == 0:
                        self.set("cmd-substitution", start)
                        break
                    elif token == "\n":
                        self.set("no-sync", start)
            return "cmd-substitution"
        # Incomplete variable
        else:
            # I would yield tokentype="variable" but "$" can appear in regexes
            #   if [[ ... =~ ^xxx$ ]]
            return ""
        raise NotImplementedError("Unreachable")

    def _read_here_doc(self, start:Location) -> None:
        assert self.text_between(start, self.tell()) == "<<", "InternalError"
        self.set("here-doc", start) # Read the first <
        self.set("here-doc", start+1) # Read the second <
        if ignore_tabs := (self.peek_token() == "-"):
            self.set("here-doc") # Read the dash in "<<-"
        self.skip_tokens(" \t") # Eat spaces
        # Get delimiter
        start:Location = self.tell()
        self.read() # Read a token for the delimiter
        end:Location = self.tell()
        delimiter:Token = self.text_between(start, end)
        while start != end:
            self.set("here-doc", start)
            start:Location = self.next_start(start)
        if not delimiter: return None
        # Check if 'EOL' or "EOL"
        ignore_tokentype:bool = delimiter[:1] in ("'", '"')
        if ignore_tokentype:
            # Remove quotes from delimiter
            delimiter:Token = delimiter[1:].removesuffix(delimiter[:1])
        # Read the here-doc
        ready_to_exit:bool = False # Only true for the end delimiter line
        subs:int = 0
        for start, token, tokentype in self.read_tokens():
            if ignore_tokentype:
                # If we are inside <<'EOL'/<<"EOL"
                self.set("inside-here-doc", start)
            else:
                # If we are inside <<EOL, respect builtins only in
                #   command-substitutions
                if tokentype == "cmd-substitution":
                    subs += token.endswith("(") - (token == ")")
                elif (tokentype != "variable") and (not subs):
                    self.set("", start) # Clear tokentype
            if token == "\n":
                if not ready_to_exit:
                    # If we are inside the here-doc, don't allow SYNC on
                    #   newlines
                    self.set("inside-here-doc", start)
                    # Check for delimiter
                    line:str = self.line_around(start+1)
                    if ignore_tabs:
                        line:str = line.lstrip("\t")
                    if line == delimiter:
                        ready_to_exit:bool = True
                        continue # Skip the set("here-doc", start)
                else:
                    break
            if ready_to_exit:
                self.set("here-doc", start)


class ColourManager(BaseColourManager):
    __slots__ = ()

    def init(self) -> None:
        self.tagdefs:dict[str,str] = ColourConfig()
        self.prog = Regex(Parser())
