from __future__ import annotations
import re

try:
    from ..colourmanager import ColourManager as BaseColourManager
    from ..colourmanager import ColourConfig as BaseColourConfig
    from ..colourmanager import Regex, Parser as BaseParser
except:
    from colourmanager import ColourManager as BaseColourManager
    from colourmanager import ColourConfig as BaseColourConfig
    from colourmanager import Regex, Parser as BaseParser


# Use `compgen -k` to build this list
KEYWORDS:set[str] = {
    "break", "case", "continue", "coproc", "do", "done", "elif",
    "else", "esac", "fi", "for", "function", "if", "in", "select",
    "then", "time", "until", "while",
}

SIGNALS_TRAPS:set[str] = {
    # Signals (generated by ChatGPT)
    "SIGINT", "SIGILL", "SIGABRT", "SIGFPE", "SIGKILL", "SIGSEGV",
    "SIGPIPE", "SIGALRM", "SIGTERM", "SIGUSR1", "SIGUSR2", "SIGCHLD",
    "SIGCONT", "SIGSTOP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGBUS",
    "SIGPOLL", "SIGPROF", "SIGSYS", "SIGEMT", "SIGSTKFLT", "SIGCLD",
    "SIGWINCH", "SIGPWR",
    # Trap signals
    "ERR", "EXIT", "DEBUG", "RETURN",
}

PROGRAMS:set[str] = {
    # Common Linux utils
    "grep", "awk", "sed", "cat", "ls", "true", "false", "tee",
    "printf", "dd", "echo", "head", "tail", "cut", "sudo", "date",
    "swapon", "swapoff", "lsblk", "xargs", "chmod", "chown",
    "chgrp", "chroot", "mkswap", "mkdir", "mount", "tar", "rm",
    "rmdir", "cp", "mv", "realpath", "readlink", "dirname", "ln",
    "basename", "git", "ls", "find", "wc", "", "", "", "", "", "",
    "", "", "",
    # Signals and traps
    *SIGNALS_TRAPS,
    # Builtins (compgen -b)
    "alias", "bg", "bind", "builtin", "caller", "cd", "command",
    "compgen", "complete", "compopt", "declare", "dirs", "disown",
    "enable", "eval", "exec", "exit", "export", "fc", "fg",
    "getopts", "hash", "help", "history", "jobs", "let", "local",
    "logout", "mapfile", "popd", "pushd", "read", "readarray",
    "readonly", "return", "set", "shift", "shopt", "source",
    "suspend", "times", "trap", "type", "typeset", "ulimit",
    "umask", "unalias", "unset", "wait",
}
PROGRAMS.discard("")

SPECIAL_VARIABLES:set[str] = set("#@*?$!-")


class ColourConfig(BaseColourConfig):
    __slots__ = ()

    def __init__(self, kwargs:dict[str:dict[str:str]]={}) -> ColourConfig:
        super().__init__({
                           "comment":           dict(foreground="red"),
                           "keyword":           dict(foreground="orange"),
                           "string":            dict(foreground="lime"),
                           "program":           dict(foreground="#ff75ff"),
                           "variable":          dict(foreground="cyan"),
                           "cmd-substitution":  dict(foreground="yellow"),
                           "here-doc":          dict(foreground="yellow"),
                           "flag":              dict(foreground="#c0c0c0"),
                           **kwargs
                        })

VARIABLE_IGNORE_TYPES:set[str] = {"cmd-substitution"}

IDENTIFIER_REGEX:str = (
                         r"^" # Begining of the string
                         r"(?:" + # One of
                             "|".join((
                                         r"[^\W\d]", # Unicode letter/_
                                         r"\[",      # [
                                         r"\]",      # ]
                                     )) + r")"
                         r"[" # Followed by any number of
                             r"\w" # Unicode letter/digit/_
                             r"\[" # [
                             r"\]" # ]
                         r"]*"
                         r"$" # End of string
                       )
IDENTIFIER_REGEX:str = re.compile(IDENTIFIER_REGEX)

def isidentifier(text:str) -> bool:
    return bool(IDENTIFIER_REGEX.fullmatch(text))


class Parser(BaseParser):
    __slots__ = ()

    def __init__(self) -> Parser:
        super().__init__(isidentifier=isidentifier, isnumber=str.isdigit)

    def read(self) -> None:
        token:Token = self.peek_token()
        # print("in:", (token,))
        if not token: return None
        if token in KEYWORDS: # Keywords
            line:str = self.curr_line_seen(respect_slashes=True).strip(" \t")
            if line.endswith(";"):
                line:str = ""
            self.set("identifier" if line else "keyword")
        elif token in PROGRAMS: # Programs
            prog:bool = False
            line:list[str] = self.curr_line_seen(respect_slashes=True).split()
            prev_token:Token = line[-1] if line else ""
            if token in SIGNALS_TRAPS:
                prog:bool = True
            elif prev_token[-1:] in ("", ";", "\n", "(", "|"):
                prog:bool = True
            elif prev_token in ("&&", "||", "if"):
                prog:bool = True
            self.set("program" if prog else "identifier")
        elif token == "#": # Comment
            self.set("comment") # Read the "#"
            while self.peek_token() != "\n": # Newline not in comment
                self.set("comment")
        elif token == "$": # $
            # Check for bashslashes before dollar
            curr_line:str = self.curr_line_seen()
            slashes:int = len(curr_line) - len(curr_line.rstrip("\\"))
            if slashes & 1:
                self.skip()
            else:
                self._read_dollar()
        elif token == "<": # here-doc
            start:Location = self.tell()
            self.skip()
            if self.peek_token() == "<":
                self.skip()
                self._read_here_doc(start)
        elif token == "-": # Flag
            if self.curr_line_seen()[-1:] in " \t-":
                self.read_flag()
            else:
                self.skip()
        elif token in "'\"": # String
            self.read_string()
        elif token in ("[","[["): # test command
            close:str = "]" * len(token)
            self.set("program")
            if self.read_wait_for({close,"&&","||",";"}) == close:
                self.set("program")
        elif token == "\\":
            self.skip()
            if self.peek_token() == "\n":
                self.set("no-sync-backslash")
        else: # Default
            self.skip()

    def dollar_only_read(self) -> None:
        token:Token = self.peek_token()
        # print("in:", (token,))
        if not token: return None
        if token == "$":
            # Check for bashslashes before dollar
            curr_line:str = self.curr_line_seen()
            slashes:int = len(curr_line) - len(curr_line.rstrip("\\"))
            if slashes & 1:
                self.skip()
            else:
                self._read_dollar()
        else: # Default
            self.skip()

    def read_flag(self) -> None:
        self.set("flag") # Read the dash
        while True:
            token:Token = self.peek_token()
            if not token:
                break
            elif token == "-": # "--flag-with-dash"
                self.set("flag")
            elif self.isidentifier("_" + token): # "-flag"
                self.set("flag")
            elif token == "=": # "--flag=value"
                self.set("flag")
                break
            else:
                break

    def read_string(self) -> None:
        single:Token = self.peek_token()
        assert single in ("'",'"'), "InternalError"
        self.set("string") # Read the starting quote
        string_start:Location = self.tell() # Right after `single`
        # Actual string reading loop
        while True:
            token:Token = self.peek_token()
            if not token: # End of file
                break
            elif token == "\n":
                self.set("string")
                if single != "'": # Newlines only stop double quote strings
                    break
            elif token == "\\":  # Slash+Character
                self.set("string") # Read the slash
                self.set("string") # Read the token after the \ (might be \n)
            elif token == single: # On string-closing
                self.set("string")
                break
            elif token == "$":
                curr:Location = self.tell()
                begining_of_string:bool = curr == string_start
                tokentype:str = self._read_dollar()
                if not tokentype:
                    self.set("string", curr)
                elif begining_of_string and (self.peek_token() == single):
                    self.set(tokentype, string_start-len(single)) # Quote
                    self.set(tokentype) # End quote
                    break
            else: # Default
                self.set("string")

    def _read_dollar(self) -> str:
        """
        Reads:
            * $(...)
            * $variable
            * ${variable}
        """
        dollar_start:Location = self.tell()
        assert self.peek_token() == "$", "InternalError"
        self.skip() # Read the dollar sign
        token:Token = self.peek_token()
        # $variable
        if self.isidentifier(token):
            self.set("variable", dollar_start)
            self.set("variable") # Read the variable
            return "variable"
        # ${variable}
        elif token == "{":
            # I am not even sure what I did here but it seems to work for
            #   now. From just this section, I started to hate bash's syntax
            # https://chatgpt.com/share/68f29e72-e504-8005-9e5f-995bf6e5de27
            self.set("variable", dollar_start)
            self.set("variable") # Read the "{"
            token:Token = self.peek_token()
            if token == "}":
                self.set("variable") # Read the "}"
                return "variable"
            if self.isidentifier(token):
                self.set("variable")
                start:Location = self.tell()
                while True:
                    token:Token = self.read_wait_for({"}","\n","#","$"},
                                                     settype="string",
                                             ignoretypes=VARIABLE_IGNORE_TYPES)
                    if token == "#":
                        self.set("string")
                    elif token == "$":
                        self.read()
                    elif token == "}":
                        self.set("variable") # Read the "}"
                        break
                    else:
                        break
            return "variable"
        # $0/$@/$#/···
        elif token.isdigit() or (token in SPECIAL_VARIABLES):
            self.set("variable", dollar_start)
            self.set("variable") # Read the token
            return "variable"
        # $(···)
        elif token == "(":
            self.set("cmd-substitution", dollar_start)
            self.set("cmd-substitution") # Read the "("
            if self.read_wait_for({")"}) == ")":
                self.set("cmd-substitution")
            return "cmd-substitution"
        # Incomplete variable
        else:
            # I would yield tokentype="variable" but "$" can appear in regexes
            #   if [[ ... =~ ^xxx$ ]]
            return ""
        raise NotImplementedError("Unreachable")

    def _read_here_doc(self, start:Location) -> None:
        assert self.text_between(start, self.tell()) == "<<", "InternalError"
        self.set("here-doc", start) # Read the first <
        self.set("here-doc", start+1) # Read the second <
        if ignore_tabs := (self.peek_token() == "-"):
            self.set("here-doc") # Read the dash in "<<-"
        self.skip_whitespaces(" \t") # Eat spaces
        start:Location = self.tell()
         # Read a token for the delimiter
        if self.peek_token() in ("'", '"'):
            self.read_string()
        else:
            self.skip()
        delimiter:Token = self.text_between(start, self.tell())
        if not delimiter: return None
        self.set_from("here-doc", start)
        # Check if 'EOL' or "EOL"
        ignore_tokentype:bool = delimiter[:1] in ("'", '"')
        if ignore_tokentype:
            # Remove quotes from delimiter
            delimiter:Token = delimiter[1:].removesuffix(delimiter[:1])
            read_func:Callable[None] = self.skip
        else:
            read_func:Callable[None] = self.dollar_only_read
        # Read the here-doc
        start:Location = self.tell()
        while True:
            token:Token = self.read_wait_for({"\n"}, read_func=read_func)
            if not token: break
            self.set("no-sync-here-doc") # Read the "\n"
            # Check for delimiter
            line:str = self.line_around(self.tell())
            if ignore_tabs:
                line:str = line.lstrip("\t")
            if line == delimiter:
                while self.peek_token() != "\n":
                    self.set("here-doc")
                break


class ColourManager(BaseColourManager):
    __slots__ = ()

    def init(self) -> None:
        self.tagdefs:dict[str,str] = ColourConfig()
        self.prog = Regex(Parser())
